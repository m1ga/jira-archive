---
title: "[AC-1339] Android memory leak"
---
<table>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>n/a</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Cannot Reproduce</td></tr>
<tr><th>Resolution Date</th><td>2014-07-09T22:19:01.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>Titanium SDK & CLI</td></tr>
<tr><th>Labels</th><td>android, httpclient, leak, memory</td></tr>
<tr><th>Reporter</th><td>Elie Khoury</td></tr>
<tr><th>Assignee</th><td>Mauro Parra-Miranda</td></tr>
<tr><th>Created</th><td>2014-06-12T20:55:46.000+0000</td></tr>
<tr><th>Updated</th><td>2016-03-08T07:37:44.000+0000</td></tr>
</table>

<h3>Description</h3>

I noticed lots of HttpClientProxy leaks in our Android application. We double checked our code, ran some tests, profiled the same code base on iOS (it was fine on iOS). Eventually we realized the the HTTPClient object is leaking only when there are concurrent xhr requests.

Test 1 (Leaks)
------------------

I built a test case and profiled it to confirm our conclusion. In test one, the app will send 20 concurrent HTTP requests. When profiled, it will show that all the HTTPClientProxy objects were leaked, even after invoking GC multiple times.

"20 instances of "ti.modules.titanium.network.HTTPClientProxy", loaded by "dalvik.system.PathClassLoader @ 0xb1083270" occupy 5,327,960 (28.38%) bytes."

Test 2 (Doesn't Leak)
----------------------------

While with test 2, the requests are queued and sent one at a time (100ms delay between every response and next request). The profile result showed that none of the HTTPClientProxy objects were leaked.
I read numerous posts on this forum and most of them were old (from 1.8 days). I'm running my tests on version 3.2.3. Android 4.3.2.

Test code below:

function xhrRequest(callback) {
    var xhr = Ti.Network.createHTTPClient({
        timeout : 5000,
        cache : false,
        onload : function(e) {
            if (callback) {
                callback();
            }
        }
    });
 
    xhr.open('POST', '<a href="https://www.yahoo.com/" rel="nofollow" target="_blank">https://www.yahoo.com/</a>');
    xhr.send();
}
 
function xhrRequestTest1(tests, callback) {
    var completed = 0;
    for (var i=0;i<tests;i++) {
        xhrRequest(function() {
            console.log('Test 1 #' + completed + ' completed');
            completed += 1;
            if (completed == tests) {
                callback();
            }
        });
    }
}
 
function xhrRequestTest2(tests, callback) {
    if (tests == 0) {
        callback();
        return;
    }
    xhrRequest(function() {
        console.log('Test 2 #' + tests + ' completed');
        setTimeout(function() {
            xhrRequestTest2(tests-1, callback);
        }, 100);
    });
 
}
 
 
var window = Ti.UI.createWindow({
    layout : 'vertical'
});
 
var button1 = Ti.UI.createButton({
    title : 'Test #1: Concurrent XHR requests'
});
 
button1.addEventListener('click', function() {
    xhrRequestTest1(20, function() {
        alert('Test 1 completed. Invoke GC and test for leaks');
    });
});
 
var button2 = Ti.UI.createButton({
    title : 'Test #2: Queued XHR requests'
});
 
button2.addEventListener('click', function() {
    xhrRequestTest2(20, function() {
        alert('Test 2 completed. Invoke GC and test for leaks');
    });
});
 
window.add(button1);
window.add(button2);
 
window.open();

<h3>Comments</h3>

<ol>
<li>Mauro Parra-Miranda 2014-06-30

   Hello Elie!
   
   I did some testing with your testcase. It doesn't prove the memory leak yet. We need a testcase that:
   
   - Does one operation (like your xhr element)
   - Then we repeat the operation
   - We can check in the heap that it's growing every time you do that operation
   - Then you simulate a Garbage Collector call in Android Monitor
   - And continue doing this operation until it shows that the memory is leaking no matter what you do (by example, running the Garbage collector, as the Android OS would do).
   
   As a result of my testing, it claims that Bitmap element is leaking more memory (using MAT). MAT will provide a clue if something is leaking, but it's not a proof yet. 
   
   If you find a testcase like the mentioned, we can move this to Platform. 
   
   Thanks a lot! </li>
<li>Mauro Parra-Miranda 2014-07-09

   Customer hasn't replied to us yet.</li>
</ol>


<p><a href="/AC/AC-1339.json">JSON Source</a></p>