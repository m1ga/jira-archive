---
title: "[ALOY-604] Events inside binded views do not work"
---
<table>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>High</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Fixed</td></tr>
<tr><th>Resolution Date</th><td>2013-06-20T19:36:34.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>Alloy 1.2.0, 2013 Sprint 13</td></tr>
<tr><th>Components</th><td>Models, XML</td></tr>
<tr><th>Labels</th><td>qe-testadded</td></tr>
<tr><th>Reporter</th><td>Pedro Enrique</td></tr>
<tr><th>Assignee</th><td>Tony Lukasavage</td></tr>
<tr><th>Created</th><td>2013-02-25T16:57:23.000+0000</td></tr>
<tr><th>Updated</th><td>2013-07-17T22:52:53.000+0000</td></tr>
</table>

<h3>Description</h3>

<h4>The Problem</h4>
When events, particularly onClick, are included on views that are childen of a model bound view the event doesn't fire and causes an error.
<h4>Test Case</h4>
<code><pre>
&lt;Alloy&gt;
	&lt;TableView dataCollection='testModel'&gt;
	  &lt;TableViewRow&gt;
	    &lt;View class="artist_row" onClick="test"&gt;
	        &lt;Label class="location" text="Location" /&gt;
	    &lt;/View&gt;
	  &lt;/TableViewRow&gt;
	&lt;/TableView&gt;
&lt;/Alloy&gt;
</pre></code>
This compiles with Alloy to:
<code><pre>
function Controller() {
    function test(e) {}
    require("alloy/controllers/BaseController").apply(this, Array.prototype.slice.call(arguments));
    $model = arguments[0] ? arguments[0].$model : null;
    var $ = this, exports = {}, __defers = {};
    $.__views.TableView = Ti.UI.createTableView({
        id: "TableView"
    });
    var __alloyId7 = function(e) {
        var models = Alloy.Collections.testModel.models, len = models.length, rows = [];
        for (var i = 0; i &lt; len; i++) {
            var __alloyId1 = models[i];
            __alloyId1.__transform = {};
            var __alloyId2 = Ti.UI.createTableViewRow({
                id: "__alloyId0"
            });
            rows.push(__alloyId2);
            var __alloyId4 = Ti.UI.createView({
                id: "__alloyId3"
            });
            __alloyId2.add(__alloyId4);
            test ? $.__views.__alloyId3.addEventListener("click", test) : __defers["$.__views.__alloyId3!click!test"] = !0;
            var __alloyId6 = Ti.UI.createLabel({
                text: "Location",
                id: "__alloyId5"
            });
            __alloyId4.add(__alloyId6);
        }
        $.__views.TableView.setData(rows);
    };
    Alloy.Collections.testModel.on("fetch destroy change add remove reset", __alloyId7);
    $.addTopLevelView($.__views.TableView);
    exports.destroy = function() {
        Alloy.Collections.testModel.off("fetch destroy change add remove reset", __alloyId7);
    };
    _.extend($, $.__views);
    __defers["$.__views.__alloyId3!click!test"] && $.__views.__alloyId3.addEventListener("click", test);
    _.extend($, exports);
}

var Alloy = require("alloy"), Backbone = Alloy.Backbone, _ = Alloy._, $model;

module.exports = Controller;
</pre></code>
The problem is that the addEventListener has been added to __views.__alloyId3 rather than __alloyId4. When run you get an error due to attempting to add a listener to an undefined object.

The problem emanates from default.js. For collection bound items the state is set to local and the children of the bound view iterated over to generate the code. With the state set to local the .parse function creates a new local id for every object created but this local id is not passed back to .generateNode where any event handlers are added. It looks like the parser can change the object symbol by returning an updated args.symbol but .parse in default.js doesn't do this. If .parse is modified by adding
<code><pre>
args: {symbol: args.symbol}
</pre></code>
to the end of the return array then the compiler does add the event handler to the locally generated view and the application works.


<h3>Comments</h3>

<ol>
<li>Tony Lukasavage 2013-04-05

   This problem is solved if you move the repeated component, in this case the TableViewRow, into its own controller. I will look into how to fix this for inline components.</li>
<li>Tony Lukasavage 2013-06-03

   While a solution is worked on for this issue, a simple workaround is to put the repeated view in its own controller. When the repeated view is created this way, the event handlers will be applied appropriately.</li>
<li>Tony Lukasavage 2013-06-20

   This was actually resolved by a commit earlier in the development of Alloy 1.2.0. 
   
   PR: <a href="https://github.com/appcelerator/alloy/pull/160" rel="nofollow" target="_blank">https://github.com/appcelerator/alloy/pull/160</a>
   test app: <a href="https://github.com/appcelerator/alloy/tree/master/test/apps/testing/ALOY-604" rel="nofollow" target="_blank">https://github.com/appcelerator/alloy/tree/master/test/apps/testing/ALOY-604</a>
   
   Functional testing can pass by running the app on all supported platforms and confirming that the "test" message is logged to the console whenever a row is clicked.</li>
<li>Federico Casali 2013-07-17

   Verified as fixed.
   
   Titanium SDK 3.1.2.v20130710144553
   Appcelerator Studio 3.1.2.201307101037
   Alloy 1.2.0
   
   Android 4.2.2 and iOS 5.
   
   Closing.</li>
</ol>


<p><a href="/ALOY/ALOY-604.json">JSON Source</a></p>