---
title: "[ALOY-647] Allow complex data binding on ListView for sections and items"
---
<table>
<tr><th>GitHub Issue</th><td><a href="https://github.com/tidev/alloy/issues/1311">https://github.com/tidev/alloy/issues/1311</a></td></tr>
<tr><th>Type</th><td>Improvement</td></tr>
<tr><th>Priority</th><td>Medium</td></tr>
<tr><th>Status</th><td>Open</td></tr>
<tr><th>Resolution</th><td>Unresolved</td></tr>

<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>Models, XML</td></tr>
<tr><th>Labels</th><td>n/a</td></tr>
<tr><th>Reporter</th><td>Tony Lukasavage</td></tr>
<tr><th>Assignee</th><td>Unknown</td></tr>
<tr><th>Created</th><td>2013-05-01T15:53:35.000+0000</td></tr>
<tr><th>Updated</th><td>2018-10-27T20:32:20.000+0000</td></tr>
</table>

<h3>Description</h3>

<h4>problem</h4>

As per ALOY-609, ListSection is the UI component which is in charge of automatically populating a ListView with ListItems via a data bound model or collection. So the dataCollection needs to be set at the <ListSection> component, not at the <ListView>:

<code><pre>
&lt;ListView id="list" defaultItemTemplate="title"&gt;
	&lt;Templates&gt;
		&lt;ItemTemplate name="fullItem" height="70"&gt;
			&lt;ImageView bindId="image" class="image"/&gt;
			&lt;Label bindId="title" class="title text-and-image"/&gt;
			&lt;Label bindId="subtitle" class="subtitle text-and-image"/&gt;
		&lt;/ItemTemplate&gt;
		&lt;ItemTemplate name="titleAndSub" height="70"&gt;
			&lt;Label bindId="title" class="title"/&gt;
			&lt;Label bindId="subtitle" class="subtitle"/&gt;
		&lt;/ItemTemplate&gt;
		&lt;ItemTemplate name="title" height="50"&gt;
			&lt;Label bindId="title" class="title"/&gt;
		&lt;/ItemTemplate&gt;
	&lt;/Templates&gt;

	&lt;ListSection id="section" dataCollection="info" dataTransform="doTransform"&gt;
		&lt;ListItem template="{template}" title:text="{title}" subtitle:text="{subtitle}" image:image="{image}"/&gt;
	&lt;/ListSection&gt;
&lt;/ListView&gt;
</pre></code>

It would be nice to be able to support complex collections, or multiple collections, in order to be able to create a section/item structure directly from a complex data model. Off the top of my head, there's probably 2 ways this can be achieved. 

<h4>proposed solution A</h4>

Resolving ALOY-614 would allow developers to use dynamically defined *dataCollection* XML attributes in their views. This would in turn allow you to define a data bound collection as a result of a prior dataCollection. For example:

<code><pre>
&lt;ListView id="list" defaultItemTemplate="title" dataCollection="someCollection"&gt;
	&lt;Templates&gt;
		&lt;!-- define templates here as usual --&gt;
	&lt;/Templates&gt;

	&lt;ListSection id="section" headerTitle="{title}" dataCollection="{nestedCollectionFromSomeCollection}"&gt;
		&lt;ListItem template="{template}" title="{title}"/&gt;
	&lt;/ListSection&gt;
&lt;/ListView&gt;
</pre></code>

<h4>proposed solution B</h4>

Develop a distinct convention for structuring of complex data such that it can all be handled internally by Alloy and the structure is just created automatically. For example, this pseudo-model shows a convention we might create in order for a <ListView> to understand that it needs to lay out the data in sections first, then items within each section:

<code><pre>
{
    viewProp: 'just some property at the ListView level'
    sections: [
        { 
            title: 'some title, would be bound to this instance of ListSection'
            items: [
                {
                    title: 'another title, would be bound to this instance of ListItem in the containing ListSection',
                    template: 'someTemplate'
                },
                // ...
            ]
        },
        // ...
    ]
</pre></code>

and the above pseudo-model would be leveraged in XML as such to create a section for each entry in the *sections* array, and an item for each entry in that section's *items* array.

<code><pre>
&lt;ListView id="list" defaultItemTemplate="title" dataCollection="thePseudoModel"&gt;
	&lt;Templates&gt;
		&lt;!-- define templates here as usual --&gt;
	&lt;/Templates&gt;

	&lt;ListSection id="section" headerTitle="{title}"&gt;
		&lt;ListItem template="{template}" title="{title}"/&gt;
	&lt;/ListSection&gt;
&lt;/ListView&gt;
</pre></code>

<h4>Notes</h4>

* option B will be modeled closely after the [ListView Titanium API](<a href="http://docs.appcelerator.com/titanium/latest/#" rel="nofollow" target="_blank">http://docs.appcelerator.com/titanium/latest/#</a>!/api/Titanium.UI.ListView) itself, being obviously a much smaller, cleaner subset as Alloy will already be taking care of styling, eventing, and templating for you.
* My initial thought is option B as it makes for cleaner markup and to me just seems like the appropriate solution. Alloy to this point has been pretty flexible in terms of letting developers manipulate it to achieve goals. This seems like one particular situation where some defined convention would make things a lot easier for everyone. Pushing the "ugliness" to the model makes more sense than pushing it into the markup.
* I'm not seeing it, but I am making anything unnecessarily difficult for developers if I go with option B? It makes some assumptions based on the data model, but I don't see anything in it that inherently limits functionality.
* option A would be quicker, but IMO, that's about the only thing it has going for it. I would prefer not to nest multiple collections and would instead prefer to make intelligent use of one. It will make for cleaner, more performant generated code and will require less Backbone-to-Alloy wiring.

<h3>Comments</h3>

<ol>
<li>farid fadaie 2014-02-10

   This will be great. </li>
<li>Nirmal 2018-10-27

   This would be a good addition. Right now we have to write JS whenever we need to construct dynamic ListSection headers.</li>
</ol>


<p><a href="/ALOY/ALOY-647.json">JSON Source</a></p>