---
title: "[ALOY-672] Alloy for binding existing Model instances to Model element"
---
<table>
<tr><th>Type</th><td>Improvement</td></tr>
<tr><th>Priority</th><td>Medium</td></tr>
<tr><th>Status</th><td>Resolved</td></tr>
<tr><th>Resolution</th><td>Duplicate</td></tr>
<tr><th>Resolution Date</th><td>2014-01-21T15:16:21.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>Models, Runtime</td></tr>
<tr><th>Labels</th><td>alloy, model, view</td></tr>
<tr><th>Reporter</th><td>Timan Rebel</td></tr>
<tr><th>Assignee</th><td>Unknown</td></tr>
<tr><th>Created</th><td>2013-05-27T10:53:44.000+0000</td></tr>
<tr><th>Updated</th><td>2018-03-07T22:25:42.000+0000</td></tr>
</table>

<h3>Description</h3>

Make it possible to bind an existing Model instance to a Model element in Alloy. 

Currently it is possible to copy the attributes into the Model element, but we do not get data binding on the original Model instance.

See: <a href="https://gist.github.com/timanrebel/5643468" rel="nofollow" target="_blank">https://gist.github.com/timanrebel/5643468</a>



<h3>Comments</h3>

<ol>
<li>Fokke Zandbergen 2013-05-27

   In order to use an existing model instance, we need to be able to refer to some existing object in memory or load one from a persistant storage.
   
   <h4>Single instance (singleton)</h4>
   One solution is to use <code>Alloy.Models.instance</code>, which works fine and is explained on:
   <a href="http://fokkezb.nl/2013/05/27/bind-existing-model/" rel="nofollow" target="_blank">http://fokkezb.nl/2013/05/27/bind-existing-model/</a>
   
   But this only works for a single concurrent instance per model, since it will take it's name from the name of the model.
   
   <h4>Multiple concurrent instances</h4>
   To be able to use multiple concurrent instance I see 2 solutions:
   
   <h4>A) Custom global instance</h4>
   We could specify a custom global instance using the existing <code>src</code> attribute:
   
   <code><pre>
   &lt;Model id="myBook" src="Alloy.Globals.books.someBook" /&gt;
   </pre></code>
   
   Which by use of '.' in <code>src</code> would trigger Alloy to compile into:
   
   <code><pre>
   $.myBook = Alloy.Globals.books.someBook;
   </pre></code>
   
   <h4>B) Local instance from singleton collection</h4>
   
   Another way could be to load a model from a existing collection singleton:
   
   <code><pre>
   &lt;Model id="myBook" src="book" instance="123" /&gt;
   </pre></code>
   
   Which by having another value then <code>true</code> (and no <code>.</code> like solution A) would compile to:
   
   <code><pre>
   $.myBook = Alloy.Collections.instance("book").book.get("123");
   </pre></code>
   
   Both A) en B) could be implemented at the same time.</li>
<li>Tony Lukasavage 2014-01-20

   [~timanrebel] you have the following in your gist:
   
   <code><pre>
   /**
    * Does not work
    */
   // $.user = args.user;
   </pre></code>
   
   Please elaborate. What actually happens when you try the direct assignment?</li>
<li>Timan Rebel 2014-01-21

   It overwrites the model created by Alloy, including its bindings and nothing happens</li>
<li>Tony Lukasavage 2014-01-21

   This will eventually be resolved a bit more robustly with a programmatic binding API (ALOY-931). In the meantime though, you can do this with straight Backbone calls. I forked your gist and modified it to do so (untested). Even if it needs tweaking, though, it should show you how you can achieve your goal of dynamically changing the binding:
   
   <a href="https://gist.github.com/tonylukasavage/8541502" rel="nofollow" target="_blank">https://gist.github.com/tonylukasavage/8541502</a></li>
</ol>


<p><a href="/ALOY/ALOY-672.json">JSON Source</a></p>