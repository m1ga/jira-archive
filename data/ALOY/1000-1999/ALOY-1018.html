---
title: "[ALOY-1018] Add defaultNamespace or module attribute to Alloy Tag"
---
<table>
<tr><th>Type</th><td>Improvement</td></tr>
<tr><th>Priority</th><td>Low</td></tr>
<tr><th>Status</th><td>Resolved</td></tr>
<tr><th>Resolution</th><td>Fixed</td></tr>
<tr><th>Resolution Date</th><td>2014-10-30T05:44:53.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>Alloy 1.7.0</td></tr>
<tr><th>Components</th><td>XML</td></tr>
<tr><th>Labels</th><td>n/a</td></tr>
<tr><th>Reporter</th><td>Jason Kneen</td></tr>
<tr><th>Assignee</th><td>Tim Poulsen</td></tr>
<tr><th>Created</th><td>2014-05-16T17:48:30.000+0000</td></tr>
<tr><th>Updated</th><td>2015-11-03T21:41:11.000+0000</td></tr>
</table>

<h3>Description</h3>

Alloy currently has a feature of specifying a module attribute against tags, allowing a custom JS module to be used to create the elements, enabling developers to return modified or different elements.

e.g:

<Label module="ui'>Foo</Label>

It's a very powerful feature and means we can create our custom tags for elements that are OS specific e.g. TitleControl and have that return a TitleControl for iOS (no change) or a Ti.UI.View for Android, with custom title text etc.

It would be useful to be able to add this namespace / module element ONCE so that you don't have to add it to every / multiple tags in a view.

So, adding the ability to specify it in the Alloy tag would mean for every tag instance, the custom module is checked first.

<Alloy module="ui.js"> for example?

<h3>Comments</h3>

<ol>
<li>Fokke Zandbergen 2014-05-16

   1) You mean <code>&lt;Alloy module="ui" &gt;</code> without <code>.js</code>
   2) This would require the compiler to require the module and check if <code>create[Tag]</code> exists.
   3) <code>module</code> rocks: <a href="http://fokkezb.nl/2013/10/21/cross-platform-ui/" rel="nofollow" target="_blank">http://fokkezb.nl/2013/10/21/cross-platform-ui/</a></li>
<li>Jason Kneen 2014-05-16

   1. Yes of course
   2. Yep
   3. Good plug.</li>
<li>Tim Poulsen 2014-07-29

   So, I can implement this. However, since I don't know which of your tags would implement some custom functionality, I have to basically copy the module attribute to every tag. This, naturally breaks the runtime code generated for every tag that your custom function doesn't implement a specific <code>create</code> function for. To fix that, I have to implement some pretty inefficient code with lots of duplication. For example, this:
   
   <code><pre>
   &lt;Alloy module="testmod"&gt;
   	&lt;Window&gt;
   		&lt;CustomButton top="100" title="Click Me"/&gt;
   	&lt;/Window&gt;
   &lt;/Alloy&gt;
   </pre></code>
   
   generates this:
   
   <code><pre>
   $.__views.index = require("testmod").createWindow ? require("testmod").createWindow({
       backgroundColor: "#fff",
       fullscreen: false,
       exitOnClose: true,
       id: "index"
   }) : Ti.UI.createWindow({
       backgroundColor: "#fff",
       fullscreen: false,
       exitOnClose: true,
       id: "index"
   });
   </pre></code>
   
   I'm sure I could optimize this more than I have here. Still, the change is going to make for rather different code generated if you do or don't use the default module attribute. I hesitate to implement such a minor productivity enhancement that comes with the potential for such results. Thoughts? Suggestions?</li>
<li>Fokke Zandbergen 2014-07-30

   Or:
   
   <code><pre>
   $.__views.index = (require("testmod").createWindow || Ti.UI.createWindow)({
       backgroundColor: "#fff",
       fullscreen: false,
       exitOnClose: true,
       id: "index"
   });
   </pre></code></li>
<li>Jason Kneen 2014-07-30

   like it</li>
<li>Tim Poulsen 2014-07-30

   Right, like I said, I can do some optimization. But is the slowdown of a runtime check for every API call in a controller worth it for the few minutes of developer time saved by not having to specify module="foo" for those couple of components for which you'll be using custom modules for?</li>
<li>Jason Kneen 2014-07-30

   I think treat this like the Dynamic TSS in Alloy - If not used sparingly it can be an overhead. If  a developer wants to go this route then it's their choice?
   
   For my TabGroup concept, I have to add the attribute to the TabGroup, Tab and Window tags. Wouldn't this have the same overhead as adding it once to the Alloy Tag wrapping the TabGroup?</li>
<li>Jason Kneen 2014-07-30

   I'd be interested in seeing it added to run some simple speed tests - see how much it does affect performance.</li>
<li>Tim Poulsen 2014-07-30

   Can you grab from here and do some tests?  <a href="https://github.com/skypanther/alloy/tree/ALOY-1018" rel="nofollow" target="_blank">https://github.com/skypanther/alloy/tree/ALOY-1018</a> 
   
   (generated code now matches Fokke's comment)</li>
<li>Fokke Zandbergen 2014-08-01

    I'm in France on a beach so if you don't mind [~jasonkneen], please test twice - one for me ;)</li>
<li>Tim Poulsen 2014-10-27

    PR <a href="https://github.com/appcelerator/alloy/pull/614" rel="nofollow" target="_blank">https://github.com/appcelerator/alloy/pull/614</a>
    
    Functional test:  Run the included ALOY\-1018 test app. You should get an app with a blue-bordered button and a pink-background label which were created with custom tags defined in the testmod module. </li>
<li>Feon Sua Xin Miao 2014-10-30

    Additional test note: 
    1. {color:blue} Blue {color} bordered custom button on iOS
    2. {color:green} Green {color} bordered custom button on Android</li>
<li>Feon Sua Xin Miao 2014-10-30

    PR merged.</li>
<li>Andrey Tkachenko 2015-09-08

    Not work for widget children. Work only if set module attribute of Alloy tag.</li>
<li>Jason Kneen 2015-09-08

    Why would you add custom tags in a widget?</li>
<li>Andrey Tkachenko 2015-09-08

    @jasonkneen for example:
    
    <code><pre>
    &lt;Widget src="..."&gt;
        &lt;Group module="widget.id/tags"&gt;
            &lt;Radio value="blackList" title="L(...)"/&gt;
            &lt;Radio value="whiteList" title="L(...)"/&gt;
        &lt;/Group&gt;
    &lt;/Widget&gt;
    </pre></code>
    
    In widget lib folder:
    <code><pre>
    function RadioGroup() {
    	this.items = [];
    }
    
    RadioGroup.prototype.add = function(radioItem) {
    	if(!(radioItem instanceof RadioItem)) {
    		throw "Must contains only Radio tag!";
    	}
    	this.items.push(radioItem);
    };
    
    function RadioItem(opts) {
    	_.extend(this, _.pick(opts, 'value', 'checked', 'title'));
    }
    
    RadioItem.prototype.add = function() {
    	throw "Radio tag cant' contains children!";
    };
    
    
    exports.createGroup = function(opts) {
    	return new RadioGroup(opts);
    };
    
    exports.createRadio = function(opts) {
    	return new RadioItem(opts);
    };
    </pre></code>
    
    Then use args.children to initialize widget.</li>
<li>Jason Kneen 2015-09-08

    Don't get why you need the widget. Just use the custom tags directly in your app. But I guess you have good reason so good luck!</li>
<li>Andrey Tkachenko 2015-09-08

    Anyway if I can add tags to the widget why I can't use module for this tags ?</li>
</ol>


<p><a href="/ALOY/ALOY-1018.json">JSON Source</a></p>