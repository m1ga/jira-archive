---
title: "[ALOY-1607] Latest underscore version is breaking removeListener method in BaseController.js"
---
<table>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>Critical</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Fixed</td></tr>
<tr><th>Resolution Date</th><td>2018-03-05T18:23:23.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>CLI Release 7.0.3</td></tr>
<tr><th>Components</th><td>Tooling</td></tr>
<tr><th>Labels</th><td>n/a</td></tr>
<tr><th>Reporter</th><td>Jorge Macias Garcia</td></tr>
<tr><th>Assignee</th><td>Feon Sua Xin Miao</td></tr>
<tr><th>Created</th><td>2018-03-01T13:36:55.000+0000</td></tr>
<tr><th>Updated</th><td>2018-04-11T21:33:01.000+0000</td></tr>
</table>

<h3>Description</h3>

Latest underscore version (1.8.3) used in Alloy 1.11.0 causes an error using *$.removeListener* method.

<a href="https://github.com/appcelerator/alloy/blob/2a25b1d50fe22d3f5c4f423a6027e1c1d7748b88/Alloy/lib/alloy/controllers/BaseController.js#L496" rel="nofollow" target="_blank">https://github.com/appcelerator/alloy/blob/2a25b1d50fe22d3f5c4f423a6027e1c1d7748b88/Alloy/lib/alloy/controllers/BaseController.js#L496</a>

I don't know why Appc Team use underscore inside BaseController.js instead use built in prototype functions like 'forEach'. In fact bump to latest underscore version is breaking the normal usage of <code>$.removeListener</code>method and this is why:

BaseController.js

<code><pre>

removeListener: function(proxy, type, callback) {
  _.each(this.__events, function(event, index) {
    if ((!proxy || proxy.id === event.id) &&
      (!type || type === event.type) &&
      (!callback || callback === event.handler)) {
      event.view.removeEventListener(event.type, event.handler);

      //This line is removing a item from __events array but a undefined value is placed in the removed index
      //self.__events.splice(index, 1); removes the item with no undefined value instead
      delete self.__events[index];
    }
  });
  return this;
}
</pre></code>


What happens in the underscore 1.8.3 version *_.each* method?
Well, it iterates in the array using a *for*, <code>undefined</code> values included.
If *event* is undefined when *event.view.removeEventListener(event.type, event.handler);* it fails because *view* isn't in event

{color:red}[ERROR] Error catched: Cannot read property 'view' of undefined{color}

<code><pre>
_.each = _.forEach = function(obj, iteratee, context) {
  iteratee = optimizeCb(iteratee, context);
  var i, length;
  if (isArrayLike(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var keys = _.keys(obj);
    for (i = 0, length = keys.length; i < length; i++) {
      iteratee(obj[keys[i]], keys[i], obj);
    }
  }
  return obj;
};
</pre></code>

What happens in the oldest underscore 1.6.0 version *_.each* method?
Well, it checks if *forEach* method is present in <code>Array.prototype</code> and uses it. This method skipes <code>undefined</code>values.


<code><pre>
var ArrayProto = Array.prototype;
var nativeForEach      = ArrayProto.forEach;

var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };
</pre></code>

Use case in Titanium:



<code><pre>
    $.addListener($.win, 'open', disableClick);
    $.addListener($.win, 'close', clean);
    $.addListener($.disable, 'click', disableClick);
    $.addListener($.label, 'click', close);

function disableClick() {
    //Removes listener but undefined value is placed
    $.removeListener($.disable, 'click', disableClick);
  }

  function close(e) {
    Ti.API.info('Closing window');
    $.win.close();
  }

  function clean(e) {
    Ti.API.info('Cleaning window');
    try {
      Ti.API.info('Call $.removeListener()');
      $.removeListener();
    } catch (err) {
      //It tries to remove event to undefined value
      //[ERROR] Error catched: Cannot read property 'view' of undefined
      Ti.API.error('Error catched: ' + err.message);
    }
  }
</pre></code>


How to solve:

How you can solve this? So easy...

First way:

Change _.each for forEach

<code><pre>
removeListener: function(proxy, type, callback) {
  this.__events.forEach(function(event, index) {
    if ((!proxy || proxy.id === event.id) &&
      (!type || type === event.type) &&
      (!callback || callback === event.handler)) {
      event.view.removeEventListener(event.type, event.handler);
      delete self.__events[index];
    }
  });
  return this;
}
</pre></code>


Second way:

Adding a simple check in the if...

<code><pre>
removeListener: function(proxy, type, callback) {
  _.each(this.__events, function(event, index) {
    if (event && (!proxy || proxy.id === event.id) &&
      (!type || type === event.type) &&
      (!callback || callback === event.handler)) {
      event.view.removeEventListener(event.type, event.handler);
      delete self.__events[index];
    }
  });
  return this;
}
</pre></code>

As Konstantin Bueschel commented a way to avoid this undefined holes inside arrays is using *splice* instead *delete*

*self.__events.splice(index, 1);*

<h3>Attachments</h3>

<table>
<thead>
<tr><th>File</th><th>Date</th><th>Size</th></tr><thead>
<tbody>
<tr><td><a href="https://jira-attachments.tisdk.com/ALOY/ALOY-1607_64914/app-removelistener.zip">app-removelistener.zip</td></td><td>2018-03-01T13:43:07.000+0000</td><td>9206826</td></tr>
</tbody>
<table>

<h3>Comments</h3>

<ol>
<li>Konstantin Bueschel 2018-03-01

   Hei,
   
   in my opinion the root cause, is the 
   
   <code><pre>
   delete self.__events[index];
   </pre></code>
   
   statement, cause it places a _null_ value at the given index. Therefore it should be replaced with the 
   
   <code><pre>
   self.__events.splice(index, 1);
   </pre></code>
   
   Besides that, I agree with Jorge, that there's not need for the underscore __.each_ usage. It would also remove the dependency on underscore and the undefined check of the iteration item.
   
   Thanx Jorge for filing this issue.</li>
<li>Jorge Macias Garcia 2018-03-01

   Yes, you are right splice removes a item in the array and not fills its position with undefined value.
   
   The solution could be both use prototype forEach and splice instead delete.</li>
<li>Jorge Macias Garcia 2018-03-02

   PR - [<a href="https://github.com/appcelerator/alloy/pull/881" rel="nofollow" target="_blank">https://github.com/appcelerator/alloy/pull/881</a>](<a href="https://github.com/appcelerator/alloy/pull/881)" rel="nofollow" target="_blank">https://github.com/appcelerator/alloy/pull/881)</a></li>
<li>Lokesh Choudhary 2018-04-11

   Verified the fix in alloy 1.12.0 in core 7.0.3-master.36.
   
   Closing.
   
   </li>
</ol>


<p><a href="/ALOY/ALOY-1607.json">JSON Source</a></p>