---
title: "[DAEMON-320] appcd-plugin: Invoke external plugins using workers"
---
<table>
<tr><th>Type</th><td>Improvement</td></tr>
<tr><th>Priority</th><td>Medium</td></tr>
<tr><th>Status</th><td>Open</td></tr>
<tr><th>Resolution</th><td>Unresolved</td></tr>

<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>appcd-plugin</td></tr>
<tr><th>Labels</th><td>n/a</td></tr>
<tr><th>Reporter</th><td>Chris Barber</td></tr>
<tr><th>Assignee</th><td>Chris Barber</td></tr>
<tr><th>Created</th><td>2020-02-11T07:12:54.000+0000</td></tr>
<tr><th>Updated</th><td>2020-04-14T21:33:12.000+0000</td></tr>
</table>

<h3>Description</h3>

Appc Daemon plugins support internal and external plugins. External plugins are run in a freshly spawned Node.js process. The external plugin communicates with the appcd core using an IPC tunnel.

One problem is serializing and deserializing data is bottlenecking throughput. By switching to Node.js 12, we can use the new worker thread library (<a href="https://nodejs.org/dist/latest-v12.x/docs/api/worker_threads.html)." rel="nofollow" target="_blank">https://nodejs.org/dist/latest-v12.x/docs/api/worker_threads.html).</a> Since worker threads run in the same process, we can take advantage of shared memory and that should be much, much faster.

Another advantage is the worker API allows us to terminate the worker and free up the memory, which is one of the biggest benefits of running a plugin in a subprocess.

We need to investigate to make sure workers cannot accidentally call <code>process.exit()</code> or something and take down the core. Furthermore, we need to make sure we can gracefully handle a plugin with bad syntax.

While workers solve many problems, we still need to keep the current design just in case a plugin needs to lock down the Node.js version.

<h3>Comments</h3>

<p>No comments</p>

<p><a href="/DAEMON/DAEMON-320.json">JSON Source</a></p>