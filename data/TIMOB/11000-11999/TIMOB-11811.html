---
title: "[TIMOB-11811] Android: Bring animation to parity with iOS capabilities"
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>Epic</td></tr>
<tr><th>Priority</th><td>Critical</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Fixed</td></tr>
<tr><th>Resolution Date</th><td>2013-07-20T18:32:28.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>Release 3.2.0</td></tr>
<tr><th>Components</th><td>Android</td></tr>
<tr><th>Labels</th><td>insight, module_animation, planning-3.2.0, qe-testadded, rock_solid</td></tr>
<tr><th>Reporter</th><td>Ingo Muschenetz</td></tr>
<tr><th>Assignee</th><td>Bill Dawson</td></tr>
<tr><th>Created</th><td>2012-11-17T08:46:21.000+0000</td></tr>
<tr><th>Updated</th><td>2017-06-27T23:27:53.000+0000</td></tr>
</table>

<h3>Description</h3>

The Android animation system has a number of shortcomings compared to iOS, particularly with regards to 3D transforms.

This epic aims to gather these separate tickets as a group so we can tackle these discrepancies.

<h3>Comments</h3>

<ol>
<li>Stephen Feloney 2013-03-30

   </li>
<li>Allen Yeung 2013-07-13

   PR: <a href="https://github.com/appcelerator/titanium_mobile/pull/4398" rel="nofollow" target="_blank">https://github.com/appcelerator/titanium_mobile/pull/4398</a></li>
<li>Martin Guillon 2013-07-30

   If i may this is not really the way to do it.
   You dont have to decompose the Matrix.
   Just compute the Android.Graphics.Matrix, then create a MatrixEvaluator. in its set method you create a MatrixAnimation which just apply the Transformation.
   I did it in my private branch. Might create a PR if needed.
   Also using that evaluator correctly handles transformations from one matrix to another. Which your implementation doesnt.
   
   To give a little more details, here is my evaluator evaluate method
   
   <code><pre>
   public Ti2DMatrix evaluate(float fraction, Ti2DMatrix startValue,
   			Ti2DMatrix endValue) {
   		if (startValue != null) {
   			Matrix m = startValue.interpolate(view, 1, childWidth, childHeight, anchorX, anchorY);
   			Matrix endM = endValue.interpolate(view, fraction, childWidth, childHeight, anchorX, anchorY);
   			m.preConcat(endM);
   			return new Ti2DMatrix(m);
   		}
   		else {
   			return new Ti2DMatrix(endValue.interpolate(view, fraction, childWidth, childHeight, anchorX, anchorY));
   		}
   	}
   </pre></code>
   
   With a little trick. When you create the Evaluator the evaluator 2DMatrix must be computed using the Matrix decomposition
   That way you correctly compute the transformation from the current Transform
   <code><pre>
   Ti2DMatrix tdm = (Ti2DMatrix) options.get(TiC.PROPERTY_TRANSFORM);
   Ti2DMatrix tdm = layoutParams.optionTransform.invert().multiply(tdm);
   </pre></code>
   </li>
<li>Bill Dawson 2013-07-30

   PR would be great.</li>
<li>Lee Morris 2017-03-22

   Closing ticket as fixed.</li>
</ol>


<p><a href="/TIMOB/TIMOB-11811.json">JSON Source</a></p>