---
title: "[TIMOB-12291] iOS: Return SQLite query result set as Javascript Object"
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>New Feature</td></tr>
<tr><th>Priority</th><td>Low</td></tr>
<tr><th>Status</th><td>Open</td></tr>
<tr><th>Resolution</th><td>Unresolved</td></tr>

<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>iOS</td></tr>
<tr><th>Labels</th><td>n/a</td></tr>
<tr><th>Reporter</th><td>Pedro Enrique</td></tr>
<tr><th>Assignee</th><td>Unknown</td></tr>
<tr><th>Created</th><td>2013-01-15T15:26:21.000+0000</td></tr>
<tr><th>Updated</th><td>2018-02-28T20:03:34.000+0000</td></tr>
</table>

<h3>Description</h3>

When looping through the result set of an SQLite query, we need to cross the bridge every time to get the results, this can be slow and painful for big databases. It would be nice to get all the results in a JS object and then work from there.

This would be ideal:
<code><pre>
    var rows = db.execute('SELECT * FROM people');

    var results = rows.asJSON();
</pre></code>

This would need to be added to TiDatabaseResultSetProxy.m
<code><pre>
-(NSDictionary *)dictionaryFromCurrentField
{
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    for(NSString *field in [results fieldNames])
    {
        [dict setObject:[results objectForColumn:field] forKey:field];
    }
    return dict;
}

-(id)asJSON:(id)args
{
    NSMutableArray *ar = [NSMutableArray array];
    if (results != nil && validRow)
    {
        [ar addObject:[self dictionaryFromCurrentField]];
        while([results next])
        {
            [ar addObject:[self dictionaryFromField]];
        }
    }
    return ar;
}
</pre></code>

<h3>Comments</h3>

<ol>
<li>Sergey Nosenko 2013-07-09

   +1 for this.
   
   For example you need to do this at js side. In general you should do FOUR "over board" proxy calls for each record.
   
   isValidRow
   getFieldName
   getField
   next
   
   so if each call is about 1-10ms at iPhone3GS for just 1000 records it will take about 3-4 SECONDS :( :( :(
   
   UPDATE: just tested code above with 1000 records on iPhone 4. 
   case 1: with default style isValidRow, then getFieldName, getField, next (then create backboneModel object for each) - 3200 miliseconds
   case 2: as asJSON (then create backboneModel object for each) - 800 miliseconds
   
   amazing performance improvement!</li>
<li>Matt Langston 2013-07-09

   This looks fine but we should also allow for "chunking" the data. For example, we should also allow for this use case:
   
   <code><pre>
       var rows = db.execute('SELECT * FROM people');
       var count = rows.count;
   
       // Ger first half of results.
       var results = rows.asJSON(count / 2);
       // process first half of results
   
       // Get remaining rows.
       results = rows.asJSON();
   </pre></code></li>
<li>Sergey Nosenko 2013-07-09

   Nice idea. 
   
   btw, I'm going to create modules (iOS and Android) with this feature, because I can't wait and need it for my applications. (3-4 seconds for 1000 records it's very slow). 
   
   UPDATE: I published module for IOS here: <a href="https://github.com/darknos/TiAdvancedDatabase" rel="nofollow" target="_blank">https://github.com/darknos/TiAdvancedDatabase</a> and I hope I didn't break any licenses agreements. </li>
<li>Martijn Kooij 2014-02-07

   Brilliant!
   I would prefer if this would be officially included in the SDK, but for now I am definitely including and using this in my app.
   
   Thanks!</li>
<li>Martijn Kooij 2014-02-07

   The code needs a small addition to take care of the BLOB data type as well.
   
   <code><pre>
   -(NSDictionary *)dictionaryFromCurrentField
   {
       NSMutableDictionary *dict = [NSMutableDictionary dictionary];
       for(NSString *field in [results fieldNames])
       {
   	    id result = [results objectForColumn:field];
   		if ([result isKindOfClass:[NSData class]]) {
   			result = [[[TiBlob alloc] initWithData:result mimetype:@"application/octet-stream"] autorelease];
   		}
           [dict setObject:result forKey:field];
       }
       return dict;
   }
   </pre></code></li>
<li>Martijn Kooij 2014-11-20

   Any update on this? I would really prefer just having this included in the default SDK instead of modifying it myself...
   
   And a new problem arises as I do also want to start supporting Android, which I can't if I have completely different methods of retrieving data...
   This issue should  not only target iOS.
   
   1. Please include the suggested modification in the SDK.
   2. Please also implement for Android.</li>
</ol>


<p><a href="/TIMOB/TIMOB-12291.json">JSON Source</a></p>