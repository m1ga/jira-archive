---
title: "[TIMOB-16105] Android: Second time a webview is loaded with a HTML5 video the video does not play"
---
<table>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>n/a</td></tr>
<tr><th>Status</th><td>Open</td></tr>
<tr><th>Resolution</th><td>Unresolved</td></tr>

<tr><th>Affected Version/s</th><td>Release 3.2.0</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>Android</td></tr>
<tr><th>Labels</th><td>3.2.0, android, api19, webview</td></tr>
<tr><th>Reporter</th><td>Wienke</td></tr>
<tr><th>Assignee</th><td>Unknown</td></tr>
<tr><th>Created</th><td>2013-12-27T15:57:42.000+0000</td></tr>
<tr><th>Updated</th><td>2018-02-28T20:04:11.000+0000</td></tr>
</table>

<h3>Description</h3>



<h3>Comments</h3>

<ol>
<li>Wienke 2013-12-28

   Added this youtube video showing the actual result:
   
   <a href="http://www.youtube.com/watch?v=0MpSpfJNyOk" rel="nofollow" target="_blank">http://www.youtube.com/watch?v=0MpSpfJNyOk</a> </li>
<li>Wienke 2013-12-28

   I did some more research and it seams that the WebView is not destroyed completely upon leaving the activity. I am currently playing around with adding things like this to the onDestroy function in the WebViewProxy:
   
   nativeWebView.stopLoading();
   nativeWebView.removeAllViews();
   nativeWebView.clearHistory();
   nativeWebView.clearCache(true);
   nativeWebView.loadUrl("about:blank");
   nativeWebView.pauseTimers(); //new code
   
   nativeWebView.destroy();
   nativeWebView = null;
   
   When trying this no webview is shown at all on opening it for a second time.</li>
<li>Wienke 2013-12-28

   Ok, I got one step further. When adding some javascript which pauses the video to the onPause method it works:
   
   	@Override
   	public void onPause(Activity activity) {
   		evalJS("document.getElementsByTagName('video')[0].pause();"); // <--- this one
   		pause();
   	}
   
   I would say this is a very ugly hack and we should investigate further on why pausing the video makes the solution. Is there a way in Android where a global playback state is kept? Can this be altered?
   
   Update: Just tested this on a bigger project with more than just the webview in the activity. And it does not work. Somehow it does not wait for the javascript to finish completely.
   
   </li>
<li>Fokke Zandbergen 2013-12-29

   [~wgiezeman], maybe your hack works better if you not rely on the external onPause event, but rather use <code>evalJS</code> upon loading the view to insert an event listener in the web view that pauses the video when it looses focus?
   
   But of course a more solid non-hack to resolve this ticket is still needed.</li>
<li>Ritu Agrawal 2013-12-30

   [~wgiezeman] Thank you very much for providing the detailed information and a video clip to reproduce the problem. We can now reproduce this problem in-house albeit inconsistently. 
   
   Moving this ticket to engineering for further evaluation and prioritization.</li>
<li>Wienke 2013-12-30

   [~ragrawal] Thanks for addressing this issue so quickly. I will continue with researching the issue as well.
   
   If I can help in any way please let me know.</li>
<li>Wienke 2013-12-30

   I spend 50 points on a bounty on this question and the answer seems quite interesting:
   
   <a href="http://stackoverflow.com/questions/20379478/android-samsung-s4-html5-video-pauses" rel="nofollow" target="_blank">http://stackoverflow.com/questions/20379478/android-samsung-s4-html5-video-pauses</a>
   
   What do you think?</li>
<li>Wienke 2013-12-30

   I tested it the solution on stackoverflow: <a href="http://stackoverflow.com/questions/20379478/android-samsung-s4-html5-video-pauses" rel="nofollow" target="_blank">http://stackoverflow.com/questions/20379478/android-samsung-s4-html5-video-pauses</a>
   
   And it is exactly the right way to solve this problem:
   
   I modified the code a bit:
   <code><pre>
   	  ((AudioManager)activity.getSystemService(
   	            activity.AUDIO_SERVICE)).requestAudioFocus(
   	                    new OnAudioFocusChangeListener() {
   	                        @Override
   	                        public void onAudioFocusChange(int focusChange) {}
   	                    }, AudioManager.STREAM_MUSIC, 
   	                    AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);
   </pre></code></li>
<li>Fokke Zandbergen 2013-12-30

   So white is the PR Wienke? ;)</li>
<li>Wienke 2013-12-30

    ;) I think putting in like this in the SDK is not the way to go. A good way to go would be adding the Audiomanager to the API so it can be controlled upon closing the activity.
    
    But that is up to the Appcelerator guys.</li>
</ol>


<p><a href="/TIMOB/TIMOB-16105.json">JSON Source</a></p>