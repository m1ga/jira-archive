---
title: "[TIMOB-16873] iOS: Switch Controls in ListViews are not reused correctly"
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>Low</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Invalid</td></tr>
<tr><th>Resolution Date</th><td>2014-04-23T17:50:57.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>Release 3.2.2</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>iOS</td></tr>
<tr><th>Labels</th><td>ListItem, ListView, Switch, ipass1</td></tr>
<tr><th>Reporter</th><td>Mahlon Gumbs</td></tr>
<tr><th>Assignee</th><td>Ingo Muschenetz</td></tr>
<tr><th>Created</th><td>2014-04-21T16:12:19.000+0000</td></tr>
<tr><th>Updated</th><td>2018-08-06T17:37:03.000+0000</td></tr>
</table>

<h3>Description</h3>

When using Switches in ListViews that contain a large enough number of records so that the user must scroll (I'm using 40 in this test), the Switch components are not reused correctly. In the attached test, you can see that tapping the switch in the first row will cause it to change in other rows as those rows are later rendered (and the switch components are reused).

<h4>Steps to reproduce</h4>
<h4>Create an app with the following files:</h4>
<code><pre>

var items = [];
for(var x=0;x&lt;40;x++){
	items.push({
		template: "tpl1",
		lbl: {
			text: "Switch #" + (x+1)
		},
		done: {
			itemId: "sw_"+x,
			value: false
		}
	});
}
$.main.setItems(items);

$.index.open();

function handleChange(e){
	console.log(JSON.stringify(e,null,2));
}
</pre></code>
<code><pre>
&lt;Alloy&gt;
	&lt;Window class="container"&gt;
		&lt;ListView id="list" defaultTemplate="tpl1"&gt;
			&lt;Templates&gt;
				&lt;ItemTemplate name="tpl1"&gt;
					&lt;View width="Ti.UI.FILL" height="50"&gt;
						&lt;Label bindId="lbl" left="5" /&gt;
						&lt;Switch bindId="done" right="5" onChange="handleChange"/&gt;
					&lt;/View&gt;
				&lt;/ItemTemplate&gt;
			&lt;/Templates&gt;
			&lt;ListSection id="main" /&gt;
		&lt;/ListView&gt;
	&lt;/Window&gt;
&lt;/Alloy&gt;
</pre></code>
<code><pre>
".container": {
	top: 40,
	backgroundColor:"white"
}
</pre></code>
<h4>Run the app and click on the first switch in the list</h4>
<h4>Scroll down and look at the other switches (need to at least scroll past the last record on the first page)</h4>

<h4>Expected Results</h4>
Only the switch that was tapped should change.
<h4>Actual Results</h4>
Other switch components are changed as well after scrolling.
<h4>Additional Info</h4>
Sometimes, scrolling back to the top will show that the wrong switch is modified (depending on the size of your list).
I've also been able to reproduce this with text fields if they all start out with the same value or and empty string ("").  Seems the reuse issue is somehow related to the initial value of the editable component.  In this example, all switches start out in the false ( off ) state.

<h3>Comments</h3>

<ol>
<li>Ritu Agrawal 2014-04-23

   Moving this ticket to engineering as I can reproduce this issue with the provided test case. Note that this ticket is similar to TIMOB-13290 but that is on the Table View.</li>
<li>Mahlon Gumbs 2014-04-23

   A couple of updates:
   <h4>I've verified the issue exists on Android as well (not iOS specific)</h4>
   <h4>It looks like it's all input components that are affected, not just Ti.UI.Switch (same test case replacing Ti.UI.Switch with Ti.UI.TextField produces the same issue). So maybe the ticket should be renamed to *Input Controls in ListViews are not reused correctly*</h4></li>
<li>Pedro Enrique 2014-04-23

   Resolving issue as invalid.
   
   As you an see in this example, the rows _are_ being reused, that's why changing the value on a switch affect others - they're the same row being reused.
   
   Solution (note that this is the way you would also do it in native) keep track of your changes and update as necessary:
   <code><pre>
   function handleChange(e){
       // Get the current "row"
       var item = e.section.getItemAt(e.itemIndex);
       // Update the switch value
       item.done.value = e.value;
       // Update the section with the new change
       e.section.updateItemAt(e.itemIndex, item);
   }
   </pre></code></li>
<li>Olga Romero 2014-04-24

   Testing the original provided code, I reproduce the issue with:
   Appcelerator Studio, build: 3.3.0.201404221437
   Titanium SDK, build 3.3.0.v20140422163054
   Node.JS Version: v0.10.13
   NPM Version: 1.3.2
   ├── acs@1.0.14
   ├── alloy@1.4.0-dev
   ├── node-appc@0.2.0
   ├── npm@1.3.2
   ├── titanium@3.3.0-dev
   └── titanium-code-processor@1.1.1-beta1
   npm -g ls titanium: /usr/local/lib
   └── titanium@3.3.0-dev  (git://github.com/appcelerator/titanium.git#93414d143051df4578b7aa42670008e5ef02c422)
   XCode Version: 5.1.1
   Device:
   iPhone5S  iOS 7.0
   
   I can reproduce it with the reported environment as well.</li>
<li>Eric Merriman  2018-08-06

   Closing as invalid. If incorrect, please reopen.</li>
</ol>


<p><a href="/TIMOB/TIMOB-16873.json">JSON Source</a></p>