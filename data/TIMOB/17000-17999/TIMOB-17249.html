---
title: "[TIMOB-17249] iOS: ImageCache keeps uncompressed image data in memory"
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>High</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Invalid</td></tr>
<tr><th>Resolution Date</th><td>2014-07-01T21:53:52.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>Release 3.2.3, Release 3.3.0</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>n/a</td></tr>
<tr><th>Labels</th><td>n/a</td></tr>
<tr><th>Reporter</th><td>Chris Bowley</td></tr>
<tr><th>Assignee</th><td>Ingo Muschenetz</td></tr>
<tr><th>Created</th><td>2014-06-30T15:36:38.000+0000</td></tr>
<tr><th>Updated</th><td>2014-07-01T21:53:52.000+0000</td></tr>
</table>

<h3>Description</h3>

When loading a remote image on iOS, the uncompressed image data is stored in memory for the duration of the app causing memory issues.

Specifically: an instance of ImageCacheEntry class is instantiated for every image fetched by URL. This holds a reference to a UIImage created from the image data on disk:

<a href="https://github.com/appcelerator/titanium_mobile/blob/master/iphone/Classes/ImageLoader.m#L76" rel="nofollow" target="_blank">https://github.com/appcelerator/titanium_mobile/blob/master/iphone/Classes/ImageLoader.m#L76</a>

As ImageCacheEntry objects are never released (AFAIK) image data is stored in memory for the duration of the app.

One possible solution is to only keep cached image data on disk and return [UIImage imageWithContentsOfFile:localPath] for -[ImageCacheEntry fullImage] instead of holding a reference to the UIImage object:

<code><pre>

- (UIImage *)fullImage {
	return [UIImage imageWithContentsOfFile:localPath];
}

</pre></code>


This code snippet loads an image every second, running object allocations in Instruments shows the image data increasing (see attached screenshot).

<code><pre>

function loadImage() {
	var url = "<a href="http://dummyimage.com/600x400/" rel="nofollow" target="_blank">http://dummyimage.com/600x400/</a>" + getRandomColor() + "/" + getRandomColor() + ".jpg&text=Hello";
	Ti.API.info(url);
	$.imageView.image = url;
}

function getRandomColor() {
    var letters = '0123456789abcdef'.split('');
    var color = '';
    for (var i = 0; i &lt; 6; i++ ) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

$.index.open();

loadImage();

setInterval(function() {
	loadImage();
}, 1000);

</pre></code>

<h3>Attachments</h3>

<table>
<thead>
<tr><th>File</th><th>Date</th><th>Size</th></tr><thead>
<tbody>
<tr><td><a href="https://jira-attachments.titaniumsdk.com/TIMOB/TIMOB-17249_49375/image_cache_jira.png">image_cache_jira.png</td></td><td>2014-06-30T15:36:38.000+0000</td><td>712789</td></tr>
<tr><td><a href="https://jira-attachments.titaniumsdk.com/TIMOB/TIMOB-17249_49410/Screenshot 2014-07-01 19.00.21.png">Screenshot 2014-07-01 19.00.21.png</td></td><td>2014-07-01T18:16:08.000+0000</td><td>220512</td></tr>
</tbody>
<table>

<h3>Comments</h3>

<ol>
<li>Mauro Parra-Miranda 2014-07-01

   Hello,
   
   after doing a change in your code, i checked this running code at Instruments, without any sign of leak. 
   
   Modified function:
   
   <code><pre>
   function loadImage() {
       var url = "<a href="http://dummyimage.com/600x400/" rel="nofollow" target="_blank">http://dummyimage.com/600x400/</a>" + getRandomColor() + "/" + getRandomColor() + ".jpg&text=Hello";
       Ti.API.info(url);
       imageView.image = null;
       imageView.image = url;
   }
   </pre></code>
   
   Full test case: 
   
   <code><pre>
   var win = Ti.UI.createWindow({
   	backgroundColor:'white',
   });
   
   var imageView = Ti.UI.createImageView({
   	image:null,
   });
   
   function loadImage() {
       var url = "<a href="http://dummyimage.com/600x400/" rel="nofollow" target="_blank">http://dummyimage.com/600x400/</a>" + getRandomColor() + "/" + getRandomColor() + ".jpg&text=Hello";
       Ti.API.info(url);
       imageView.image = null;
       imageView.image = url;
   }
    
   function getRandomColor() {
       var letters = '0123456789abcdef'.split('');
       var color = '';
       for (var i = 0; i &lt; 6; i++ ) {
           color += letters[Math.floor(Math.random() * 16)];
       }
       return color;
   }
    
   win.open();
   win.add(imageView);
   loadImage();
    
   setInterval(function() {
       loadImage();
   }, 1000);
   </pre></code>
   
   Best Regards</li>
<li>Chris Bowley 2014-07-01

   Mauro, sorry if I didn't explain the issue clearly but I specifically didn't report this as a memory leak. Image data is cached and stored in memory for the lifetime of the application, whether or not the visible image view is destroyed.
   
   For each image fetched by URL we create an ImageCacheEntry object with a reference to a UIImage object containing the image data. This is held in memory. With or without nulling out the image view in JS, this reference is stored in memory for the life of the application. This does not result in a leak displayed in instruments because this is how the image cache has been implemented. However there is no way from JS to remove this cached data so it increases with every remote image fetched. My suggestion is to keep the cached image data on disk and only load into memory when required for display - see Description.
   
   Use the allocations instrument and you will see the number of ImageCacheEntry objects increasing and memory allocated to ImageIO_jpeg_Data increasing, as shown in my attached screenshot. I have run the code again with the additional line nulling out the image but the result is the same - see attached.
   
   Chris
   
   </li>
<li>Mauro Parra-Miranda 2014-07-01

   Hello Chris!
   
   I tested again with your view (only tracking the allocations) and it's clear that the GC is kicking in and cleaning the ImageIO component (you will see a stair in the graph). Check the image here: <a href="http://picpaste.com/81ly5UL2.png" rel="nofollow" target="_blank">http://picpaste.com/81ly5UL2.png</a> 
   
   From your screenshot, that is happening in iOS8. iOS 8 is not final yet, and likely to contain bugs (like a faulty GC). 
   
   Best Regards 
   </li>
<li>Chris Bowley 2014-07-01

   Hi Mauro
   
   I'm not sure why but I don't see any GC behaviour on 3.2.3/3.3.0 iOS 7 on simulator and iPhone 5. ImageCacheEntry objects and ImageIO continue to increase.
   
   I'm using your code but would you be able to post your project so I can be sure I'm running the same thing? You can get my test project here: <a href="https://www.dropbox.com/s/0c3jabu6cd2fz3g/ImageCacheTest.zip." rel="nofollow" target="_blank">https://www.dropbox.com/s/0c3jabu6cd2fz3g/ImageCacheTest.zip.</a>
   
   </li>
<li>Mauro Parra-Miranda 2014-07-01

   Hello [~cbowley], 
   
   here is my project:
   
   <a href="https://drive.google.com/file/d/0B439umN-AOyxRHpyTnBybW9fM0U/edit?usp=sharing" rel="nofollow" target="_blank">https://drive.google.com/file/d/0B439umN-AOyxRHpyTnBybW9fM0U/edit?usp=sharing</a>
   
   Best Regards</li>
<li>Chris Bowley 2014-07-01

   Mauro
   
   It looks like I simply haven't run the app for long enough for the cache to be purged - it took over 6 minutes to kick in. Sorry for raising the issue and thanks for investigating it.
   
   Chris</li>
</ol>


<p><a href="/TIMOB/TIMOB-17249.json">JSON Source</a></p>