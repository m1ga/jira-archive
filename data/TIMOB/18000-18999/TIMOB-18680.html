---
title: "[TIMOB-18680] iOS - Incorrect Caching of ListItems containing Textfields"
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>Critical</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Fixed</td></tr>
<tr><th>Resolution Date</th><td>2015-03-17T21:21:11.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>Release 3.5.1</td></tr>
<tr><th>Fix Version/s</th><td>Release 4.1.0</td></tr>
<tr><th>Components</th><td>iOS</td></tr>
<tr><th>Labels</th><td>ListItem, ListView, index</td></tr>
<tr><th>Reporter</th><td>Justin Toth</td></tr>
<tr><th>Assignee</th><td>Vishal Duggal</td></tr>
<tr><th>Created</th><td>2015-03-04T23:10:06.000+0000</td></tr>
<tr><th>Updated</th><td>2015-06-15T08:31:41.000+0000</td></tr>
</table>

<h3>Description</h3>

One of our Titanium apps uses ListViews extensively, including for building forms, where each ListItem contains a form control (TextField, Picker, etc...) If the form has more ListItems than the size of the screen, as you scroll down it causes issues where the values from certain TextFields are copied into other ListItems' TextFields.

This is clearly connected to the ListView's row caching, it's expected that it would cache the list rows so that you only have as many as are on the screen in memory, however it's clearly not setting the values correctly for each row as scrolling occurs.

I've boiled it down to a simple reproduction case below, simply input values into the first few rows (e.g. "test 1", "test 2", "test 3") then scroll down and you'll see those 3 values populated into other rows.

<code><pre>
var win = Ti.UI.createWindow({ backgroundColor: 'white' });

var defaultTemplate = {
    childTemplates: [
        {
            type: 'Ti.UI.Label',
            bindId: 'label',
            properties: {
                top: '5dp', left: '5dp'
            }
        },
        {
            type: 'Ti.UI.TextField',
            bindId: 'value',
            properties: {
                top: '30dp', left: '5dp', right: '5dp', bottom: '5dp',
                backgroundColor: 'gray', color: 'black', height: '40dp'
            }
        }
    ]
};

var listView = Ti.UI.createListView({
    top: '20dp',
    templates: { 'default': defaultTemplate },
    defaultItemTemplate: 'default',
    rowHeight: '70dp',
    backgroundColor: '#eff3fa',
    showVerticalScrollIndicator: true,
    separatorColor: '#e3ece7', separatorInsets: { left: 0, right: 0 }
});

var items = [];
for (var k=0;k&lt;40;k++) {
    var label = 'Item ' + (k + 1);
    items.push({
        label: { text: label },
        value: { text: '' }
    });
}

var sections = [
    Ti.UI.createListSection({
        headerTitle: 'Only Section',
        items: items
    })
];

listView.setSections(sections);

win.add(listView);
win.open();
</pre></code>

<h3>Comments</h3>

<ol>
<li>Pedro Enrique 2015-03-11

   Hi Justin,
   
   What you are seeing is the default behavior. To update the content of the textfield, you need to update the data. There's documentation here: <a href="http://docs.appcelerator.com/titanium/latest/#" rel="nofollow" target="_blank">http://docs.appcelerator.com/titanium/latest/#</a>!/guide/ListViews
   
   For example, I changed the template to make it more readable, value is now called textField. I also added an event to the textfield.
   <code><pre>
   var defaultTemplate = {
       childTemplates: [
           {
               type: 'Ti.UI.Label',
               bindId: 'label',
               properties: {
                   top: '5dp', left: '5dp'
               }
           },
           {
               type: 'Ti.UI.TextField',
               bindId: 'textField',
               properties: {
                   top: '30dp', left: '5dp', right: '5dp', bottom: '5dp',
                   backgroundColor: 'gray', color: 'black', height: '40dp'
               },
               events: {
               	blur: onTextfieldBlur
               }
           }
       ]
   };
   </pre></code>
   Then declare the event function to be called, and there update the listview data:
   <code><pre>
   function onTextfieldBlur(e) {
       var item = e.section.getItemAt(e.itemIndex);
       item.textField.value = e.value;
       e.section.updateItemAt(e.itemIndex, item);  
   }
   </pre></code>
   
   Resolving, this is not a bug</li>
<li>Justin Toth 2015-03-11

   It seems like you didn't test your code, as it still has the same issue as in my original sample... The issue is that rows are cached and reused, simply updating the textfield's value manually on blur does nothing to address that issue. 
   
   It also leaves a nasty side effect where if you click from one textfield to another, the second one won't gain focus, as the section.updateItemAt will recreate the section and focus is lost.
   
   Please reopen the ticket.
   
   <code><pre>
   var win = Ti.UI.createWindow({ backgroundColor: 'white' });
   
   var defaultTemplate = {
       childTemplates: [
           {
               type: 'Ti.UI.Label',
               bindId: 'label',
               properties: {
                   top: '5dp', left: '5dp'
               }
           },
           {
               type: 'Ti.UI.TextField',
               bindId: 'textField',
               properties: {
                   top: '30dp', left: '5dp', right: '5dp', bottom: '5dp',
                   backgroundColor: 'gray', color: 'black', height: '40dp'
               },
               events: {
                   blur: onTextfieldBlur
               }
           }
       ]
   };
   
   var listView = Ti.UI.createListView({
       top: '20dp',
       templates: { 'default': defaultTemplate },
       defaultItemTemplate: 'default',
       rowHeight: '70dp',
       backgroundColor: '#eff3fa',
       showVerticalScrollIndicator: true,
       separatorColor: '#e3ece7', separatorInsets: { left: 0, right: 0 }
   });
   
   var items = [];
   for (var k=0;k&lt;40;k++) {
       var label = 'Item ' + (k + 1);
       items.push({
           label: { text: label },
           textField: { text: '' }
       });
   }
   
   var sections = [
       Ti.UI.createListSection({
           headerTitle: 'Only Section',
           items: items
       })
   ];
   
   listView.setSections(sections);
   
   win.add(listView);
   win.open();
   
   function onTextfieldBlur(e) {
       var item = e.section.getItemAt(e.itemIndex);
       item.textField.value = e.value;
       e.section.updateItemAt(e.itemIndex, item);
   }
   </pre></code></li>
<li>Vishal Duggal 2015-03-12

   A couple of issues with the sample code.
   
   One the property to be used with the <code>textField</code> bindId is <code>value</code> not <code>text</code>.
   Second the reason the keyboard disappears on selecting a second text field is because the updateItemAt does not specify an animated parameter which implicitly sets animated to false. In this scenario we have to reload the whole table.
   
   Either ways there is an issue with ListView's reuse of Proxies and underlying views. Will setup a PR to fix this.
   Test case
   <code><pre>
   var win = Ti.UI.createWindow({ backgroundColor: 'white' });
   
    
   
   var defaultTemplate = {
   
       childTemplates: [
   
           {
   
               type: 'Ti.UI.Label',
   
               bindId: 'label',
   
               properties: {
   
                   top: '5dp', left: '5dp'
   
               }
   
           },
   
           {
   
               type: 'Ti.UI.TextField',
   
               bindId: 'textField',
   
               properties: {
   
                   top: '30dp', left: '5dp', right: '5dp', bottom: '5dp',
   
                   backgroundColor: 'gray', color: 'black', height: '40dp'
   
               },
   
               events: {
   
                   blur: onTextfieldBlur,
   
               }
   
           }
   
       ]
   
   };
   
    
   
   var listView = Ti.UI.createListView({
   
       top: '20dp',
   
       templates: { 'default': defaultTemplate },
   
       defaultItemTemplate: 'default',
   
       rowHeight: '70dp',
   
       backgroundColor: '#eff3fa',
   
       showVerticalScrollIndicator: true,
   
       separatorColor: '#e3ece7', separatorInsets: { left: 0, right: 0 }
   
   });
   
    
   
   var items = [];
   
   for (var k=0;k&lt;40;k++) {
   
       var label = 'Item ' + (k + 1);
   
       items.push({
   
           label: { text: label },
   
           textField: { value: '' }
   
       });
   
   }
   
    
   
   var sections = [
   
       Ti.UI.createListSection({
   
           headerTitle: 'Only Section',
   
           items: items
   
       })
   
   ];
   
    
   
   listView.setSections(sections);
   
    
   
   win.add(listView);
   
   win.open();
   
    
   
   function onTextfieldBlur(e) {
      var item = e.section.getItemAt(e.itemIndex);
   
       item.textField.value = e.value;
   
       e.section.updateItemAt(e.itemIndex, item, {animated:true});
   
   }
   </pre></code></li>
<li>Vishal Duggal 2015-03-12

   Pull pending
   master - <a href="https://github.com/appcelerator/titanium_mobile/pull/6718" rel="nofollow" target="_blank">https://github.com/appcelerator/titanium_mobile/pull/6718</a></li>
<li>Justin Toth 2015-03-29

   I've tested and confirmed that the row caching issue is resolved when using master and the two changes that Vishal suggested (value instead of text and animated: true). Thanks Pedro and Vishal for looking into the issue!</li>
<li>Satyam Sekhri 2015-06-15

   The issue is fixed. No caching of list items.
   Verified using the code mentioned by Vishal.
   
   Verified on:
   Mac OS 10.10.1
   Ti SDK: 4.1.0.v20150614181235
   Appc Studio: 4.1.0.201506120823
   Appc CLI Registry: 4.0.2
   Appc CLI NPM: 4.0.1
   Device: iPhone 6plus (v8.3), iPhone 5S simulator (v7.1)</li>
</ol>


<p><a href="/TIMOB/TIMOB-18680.json">JSON Source</a></p>