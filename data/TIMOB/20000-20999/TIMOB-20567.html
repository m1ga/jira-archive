---
title: "[TIMOB-20567] Hyperloop: Allow class usage with only the framework being required"
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>Improvement</td></tr>
<tr><th>Priority</th><td>High</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Won't Fix</td></tr>
<tr><th>Resolution Date</th><td>2018-04-19T10:45:30.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>Hyperloop, iOS</td></tr>
<tr><th>Labels</th><td>frameworks, hyperloop, ios</td></tr>
<tr><th>Reporter</th><td>Hans Knöchel</td></tr>
<tr><th>Assignee</th><td>Unknown</td></tr>
<tr><th>Created</th><td>2016-03-15T12:49:12.000+0000</td></tr>
<tr><th>Updated</th><td>2018-08-02T22:20:02.000+0000</td></tr>
</table>

<h3>Description</h3>

Currently, when we want to use a <code>UILabel</code> with Hyperloop, we need to require it the following way:
*iOS*:
<code><pre>
var UILabel = require("UIKit/UILabel");
</pre></code>
Now if we want to use another class from the <code>UIKit</code> framework e.g. <code>UIView</code>, we need to do:
<code><pre>
var UIView = require("UIKit/UIView");
</pre></code>

The approach is to make it possible to require frameworks like we do it in Swift/Objective-C and expose the available classes automatically:
<code><pre>
require("UIKit"); // Can we do this require-statement anonymously?

var view = new UIView();
var label = new UILabel();
</pre></code>
In addition, Alloy does a similar kind of pre-processing to expose variables like <code>OS_IOS</code> and <code>arguments</code> in new controllers.

<h3>Comments</h3>

<ol>
<li>Hans Knöchel 2016-03-15

   /cc [~penrique] & [~jhaynie]</li>
<li>Christopher Williams 2016-03-15

   Something else to consider: What about ES6 module import syntax?
   
   <code><pre>
   import { UILabel, UIView } from 'UIKit';
   </pre></code></li>
<li>Hans Knöchel 2016-03-15

   [~cwilliams] +1, we focus ES6 for 6.0.0. Would need to shift the issue then. Discussions welcome.</li>
<li>Hans Knöchel 2016-04-13

   I just thought of wildcard patterns like 
   <code><pre>
   var view = require("android.view.*")
   </pre></code>
   in Android, but that's not good practice right? Are there API's where package wildcards would make access?</li>
<li>Christopher Williams 2016-04-13

   It's fairly standard practice to use wildcards in java package imports. Most IDEs/tooling automatically expand it out the the actual types you use, so that the wildcard isn't used - probably just to be more specific/improve performance.
   
   So I think it would make sense to do an ES6 style import with a wildcard:
   <code><pre>
   import { View, Gravity } from 'android.view.*';
   import { List, Map } from 'java.util.*';
   </pre></code>
   
   for ES5 syntax? I guess we'd have to have the require return an object with type names as keys inside it:
   <code><pre>
   var ViewPackage = require('android.view.*'),
       View = ViewPackage.View,
       Gravity = ViewPackage.Gravity;
   </pre></code></li>
<li>Christopher Williams 2016-04-13

   BTW, I'd suggest that this ticket be cloned out for the android implementation vs iOS implementation.</li>
<li>Hans Knöchel 2016-04-22

   You are right, that are two different cases. Do we want to put this in 5.4.0 already or 6.0.0? </li>
<li>Hans Knöchel 2018-04-19

   Resolving as <code>Won't Fix</code> since we have ES6 support in Hyperloop 3.1.0 and later already, which can be used for module based import of native frameworks, classes and enums.</li>
<li>Eric Merriman  2018-08-02

   Closing old "Won't fix" tickets. If you disagree, please reopen.</li>
</ol>


<p><a href="/TIMOB/TIMOB-20567.json">JSON Source</a></p>