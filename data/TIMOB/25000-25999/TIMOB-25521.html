---
title: "[TIMOB-25521] ERROR : [Pixel] BroadcastReceiver: java.lang.RuntimeException: BroadcastReceiver trying to return result during a non-ordered broadcast"
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>None</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Duplicate</td></tr>
<tr><th>Resolution Date</th><td>2017-11-18T02:06:56.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>n/a</td></tr>
<tr><th>Labels</th><td>n/a</td></tr>
<tr><th>Reporter</th><td>Jebun Naher</td></tr>
<tr><th>Assignee</th><td>Jebun Naher</td></tr>
<tr><th>Created</th><td>2017-11-16T12:12:19.000+0000</td></tr>
<tr><th>Updated</th><td>2017-11-18T02:06:56.000+0000</td></tr>
</table>

<h3>Description</h3>

*Note:* This error occurs only on google pixel device, running android 8.0.0

*Issue Description:*
When my app is closed or in the background and I am sending push notification through appcelerator dasboard, I get the error below. I am only getting this error on one device. The other device I am testing with does not have any errors.

*Error Log:*
<code><pre>
[ERROR] : [Pixel] BroadcastReceiver: BroadcastReceiver trying to return result during a non-ordered broadcast
[ERROR] : [Pixel] BroadcastReceiver: java.lang.RuntimeException: BroadcastReceiver trying to return result during a non-ordered broadcast
[ERROR] : [Pixel] BroadcastReceiver: at android.content.BroadcastReceiver.checkSynchronousHint(BroadcastReceiver.java:649)
[ERROR] : [Pixel] BroadcastReceiver: at android.content.BroadcastReceiver.setResultCode(BroadcastReceiver.java:415)
[ERROR] : [Pixel] BroadcastReceiver: at com.appcelerator.aps.GCMReceiver.onReceive(GCMReceiver.java:32)
[ERROR] : [Pixel] BroadcastReceiver: at android.app.ActivityThread.handleReceiver(ActivityThread.java:3252)
[ERROR] : [Pixel] BroadcastReceiver: at android.app.ActivityThread.-wrap17(Unknown Source:0)
[ERROR] : [Pixel] BroadcastReceiver: at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1677)
[ERROR] : [Pixel] BroadcastReceiver: at android.os.Handler.dispatchMessage(Handler.java:105)
[ERROR] : [Pixel] BroadcastReceiver: at android.os.Looper.loop(Looper.java:164)
[ERROR] : [Pixel] BroadcastReceiver: at android.app.ActivityThread.main(ActivityThread.java:6541)
[ERROR] : [Pixel] BroadcastReceiver: at java.lang.reflect.Method.invoke(Native Method)
[ERROR] : [Pixel] BroadcastReceiver: at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)
[ERROR] : [Pixel] BroadcastReceiver: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767)
</pre></code>

*Steps to reproduce: (As per client)*

When the app is started up the device token gets registered and stored. 
When clicking on the button, the device token is used to subscribe them to the channel which is made by providing some data (testing has been done using channel name 2_1). 
I can confirm that the device token is being registered and stored correctly and the device is successfully subscribing to the channel.

Using Axway dashboard mobile backend services of this app, I am sending through push notifications to all devices subscribed to channel 2_1. 

When the app is open and running on the device, an alert is shown displaying the notification payload.

*However when the app is not open at all or is running in the background, the device should receive a push notification. It is at this point that the error is shown in the console log and no push notification is displayed on the device. All other testing devices are displaying the push notifications as expected at this point*

*Test Code:*
*Alloy.js*
function processPushNotifications(e) {
console.log("running processPushNotifications ");
alert('Received push: ' + JSON.stringify(e));
}//function

function processDeviceToken(deviceToken){
if (null != deviceToken) {
console.log("saving device token");
Ti.App.Properties.setString('deviceToken', deviceToken);
} else {
console.log("NO DEVICE TOKEN!!");
}//if
}//function

var iiFunctions = require('iceberg/ii-functions');

if (OS_ANDROID){
console.log("running iiRegisterDeviceToken");
iiFunctions.iiRegisterDeviceToken(processDeviceToken, processPushNotifications);

} else if (OS_IOS) {

var arrConfig = [Ti.App.iOS.USER_NOTIFICATION_TYPE_ALERT, Ti.App.iOS.USER_NOTIFICATION_TYPE_SOUND, Ti.App.iOS.USER_NOTIFICATION_TYPE_BADGE];
console.log("running iiRegisterDeviceToken");
iiFunctions.iiRegisterDeviceToken(processDeviceToken, processPushNotifications, arrConfig);
}

*iifunctions.js*
<code><pre>
exports.iiRegisterDeviceToken = function(callback, pushNotificationsCallback, arrTypes) {

if (OS_ANDROID) {

var CloudPush = require('ti.cloudpush');	

//Initialise the module
console.log("retrieving device token");
CloudPush.retrieveDeviceToken({
success: function(e) {
console.log("*********");
console.log("success");
console.log("*********");
callback(e.deviceToken);

}//function
,error: function(e){
console.log("*********");
console.log("error");
console.log("*********");
console.log(e.error);
}//function
});

//Process incoming push notifications
if ('undefined' != typeof pushNotificationsCallback) {
CloudPush.addEventListener('callback', function(evt) {
console.log("recieved notification, running callback");
pushNotificationsCallback(evt.payload);
});
}//if

} else if (OS_IOS) { 

//Check if the device is running iOS 8 or later
if (parseInt(Ti.Platform.version.split(".")[0]) &gt;= 8) {
console.log("greater than ios 8");
//Wait for user settings to be registered before registering for push notifications
Ti.App.iOS.addEventListener('usernotificationsettings', function registerForPush() {

//Remove event listener once registered for push notifications
Ti.App.iOS.removeEventListener('usernotificationsettings', registerForPush); 

Ti.Network.registerForPushNotifications({
success: function(e) {
console.log("success");
callback(e.deviceToken);
}//function
,callback: function(e) {
pushNotificationsCallback(e);
}//function
});

});

// Register notification types to use
Ti.App.iOS.registerUserNotificationSettings({
types: arrTypes
});
console.log("set types");

} else {
console.log("less than 8");
Ti.Network.registerForPushNotifications({
types: arrTypes
,success: function(e) {
console.log("success");
callback(e.deviceToken);
}//function
,callback: function(e) {
pushNotificationsCallback(e);
}//function
});

}//if

}//if

};
var deviceToken = Ti.App.Properties.getString('deviceToken');

if (null !== deviceToken){

var Cloud = require("ti.cloud");
var channelName = functions.makeChannelName(callbackParams.schoolId, callbackParams.yearGroupId);

Cloud.PushNotifications.subscribeToken({
device_token: deviceToken,
channel: channelName,
type: Ti.Platform.name == 'android' ? 'android' : 'ios'
}, function (e) {
if (e.success) {
console.log("subscribed to channel " + channelName);
} else {
console.log('Error:\n' + ((e.error && e.message) || JSON.stringify(e)));
}//if
});

} else {
console.log("No device token available");
}//if
</pre></code>

*functions.js*
<code><pre>
exports.makeChannelName = function(schoolId, intYearGroupId) {
console.log("4 = " + schoolId);
return (schoolId + '_' + intYearGroupId).trim();

};
</pre></code>

*Expected:*
Push notification should be received without any error.

*Actual:*
Error occurs when receiving the notification



<h3>Comments</h3>

<p>No comments</p>

<p><a href="/TIMOB/TIMOB-25521.json">JSON Source</a></p>