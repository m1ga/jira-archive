---
title: "[TIMOB-27848] Android: Ti.Database wrongly stores booleans/numbers as strings via query parameters"
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>Low</td></tr>
<tr><th>Status</th><td>Open</td></tr>
<tr><th>Resolution</th><td>Unresolved</td></tr>

<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>Android</td></tr>
<tr><th>Labels</th><td>android, database, parameters, parity, query, type</td></tr>
<tr><th>Reporter</th><td>Joshua Quick</td></tr>
<tr><th>Assignee</th><td>Joshua Quick</td></tr>
<tr><th>Created</th><td>2020-04-14T02:27:55.000+0000</td></tr>
<tr><th>Updated</th><td>2020-04-17T18:19:22.000+0000</td></tr>
</table>

<h3>Description</h3>

*Summary:*
The <code>Ti.Database</code> module's <code>DB.execute()</code> method wrongly stores values of type <code>boolean</code> and <code>number</code> as type <code>string</code> when passed via query parameters.

<code><pre>
// Will store boolean false as string "false". Should be stored as number 0.
db.execute("INSERT INTO data(value) VALUES (?)", false);

// Will store number as string "123.456". Should be stored as number.
db.execute("INSERT INTO data(value) VALUES (?)", 123.456);
</pre></code>

*Note:*
This is not an issue on iOS. Values of type <code>boolean</code> and <code>number</code> are stored as numbers. Also note that SQLite does not natively support boolean types and will be stored as integers instead.

*Steps to reproduce:*
<h4>Build and run the below code on Android.</h4>
<h4>Look in the log.</h4>

<code><pre>
var dbConnection = Ti.Database.open("test.db");
dbConnection.execute("CREATE TABLE IF NOT EXISTS properties(name PRIMARY KEY, value);");
var sqlInsertStatement = "INSERT OR REPLACE INTO properties(name, value) VALUES (?, ?);";
dbConnection.execute(sqlInsertStatement, "null", null);
dbConnection.execute(sqlInsertStatement, "boolean-false", false); // uh-oh!
dbConnection.execute(sqlInsertStatement, "boolean-true", true);   // uh-oh!
dbConnection.execute(sqlInsertStatement, "integer-0", 0);         // uh-oh!
dbConnection.execute(sqlInsertStatement, "integer-2", 2);         // uh-oh!
dbConnection.execute(sqlInsertStatement, "float", 123.456);       // uh-oh!
dbConnection.execute(sqlInsertStatement, "string-empty", "");
dbConnection.execute(sqlInsertStatement, "string-not-empty", "Hello World");
var resultSet = dbConnection.execute("SELECT name, value FROM properties;");
while (resultSet.isValidRow()) {
	var name = resultSet.field(0);
	var value = resultSet.field(1);
	Ti.API.info(<code>@@@ db entry "${name}": ${value} (type ${typeof value})</code>);
	resultSet.next();
}
dbConnection.close();
</pre></code>

*Results from Android:*
Notice entries of type boolean, integer, and float are of type string. They should all be of type number.
<code><pre>
[INFO]  @@@ db entry "null": null (type object)
[INFO]  @@@ db entry "boolean-false": false (type string)
[INFO]  @@@ db entry "boolean-true": true (type string)
[INFO]  @@@ db entry "integer-0": 0 (type string)
[INFO]  @@@ db entry "integer-2": 2 (type string)
[INFO]  @@@ db entry "float": 123.456 (type string)
[INFO]  @@@ db entry "string-empty":  (type string)
[INFO]  @@@ db entry "string-not-empty": Hello World (type string)
</pre></code>

*Results from iOS:*
<code><pre>
[INFO]  @@@ db entry "null": null (type object)
[INFO]  @@@ db entry "boolean-false": 0 (type number)
[INFO]  @@@ db entry "boolean-true": 1 (type number)
[INFO]  @@@ db entry "integer-0": 0 (type number)
[INFO]  @@@ db entry "integer-2": 2 (type number)
[INFO]  @@@ db entry "float": 123.456 (type number)
[INFO]  @@@ db entry "string-empty":  (type string)
[INFO]  @@@ db entry "string-not-empty": Hello World (type string)
</pre></code>

*Native Android Limitations:*
There's a HUGE limitation on Google's end where its Java [SQLiteDatabase](<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase)" rel="nofollow" target="_blank">https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase)</a> class only supports query parameters of type <code>String</code> for its <code>SELECT</code> query methods.
[SQLiteDatabase.rawQuery()](<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase#rawQuery(java.lang.String" rel="nofollow" target="_blank">https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase#rawQuery(java.lang.String</a>,%20java.lang.String%5B%5D))

This class does not have this limitation for its SQL execution methods which take <code>Object[]</code> arrays for query params which we can use for <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, etc., but these methods cannot returns rows.
[SQLiteDatabase.execSQL()](<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase#execSQL(java.lang.String" rel="nofollow" target="_blank">https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase#execSQL(java.lang.String</a>,%20java.lang.Object%5B%5D))
[SQLiteStatement.execute()](<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteStatement)" rel="nofollow" target="_blank">https://developer.android.com/reference/android/database/sqlite/SQLiteStatement)</a>

So, Google not providing an API to allow a <code>SELECT</code> with a numeric query parameter is a huge blocker for this ticket.

*Work-Around:*
When creating a table, assign the column a numeric affinity such as <code>NUMERIC</code>, <code>INTEGER</code>, or <code>REAL</code>. SQLite will automatically convert parameter values to that numeric affinity if possible. You can still store strings to a numeric column. However, a boolean will still be stored as a string.
<code><pre>
CREATE TABLE IF NOT EXISTS properties(name PRIMARY KEY, value NUMERIC);
</pre></code>



<h3>Comments</h3>

<p>No comments</p>

<p><a href="/TIMOB/TIMOB-27848.json">JSON Source</a></p>