---
title: "[TIMOB-7413] Android: Function variables for Windows methods cannot be successfully invoked."
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>Bug</td></tr>
<tr><th>Priority</th><td>High</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Invalid</td></tr>
<tr><th>Resolution Date</th><td>2012-02-08T17:20:47.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>Release 1.8.0.1, Release 2.0.0, Release 1.8.1</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>Android</td></tr>
<tr><th>Labels</th><td>qe-and012312</td></tr>
<tr><th>Reporter</th><td>Dustin Hyde</td></tr>
<tr><th>Assignee</th><td>Bill Dawson</td></tr>
<tr><th>Created</th><td>2012-01-25T17:23:25.000+0000</td></tr>
<tr><th>Updated</th><td>2013-05-01T20:06:59.000+0000</td></tr>
</table>

<h3>Description</h3>

The following app.js results in a runtime error in both runtimes:

<code><pre>
var f = Ti.UI.createWindow().open;
f();
</pre></code>

The error:

<code><pre>
E/TiJSError(  764): (main) [512,1939] ----- Titanium Javascript Runtime Error -----
E/TiJSError(  764): (main) [1,1940] - In ti:/window.js:173,38
E/TiJSError(  764): (main) [0,1940] - Message: Uncaught TypeError: Cannot read property 'closed' of undefined
E/TiJSError(  764): (main) [0,1940] - Source: 		if (this.currentState != this.state.closed) {
E/V8Exception(  764): Exception occurred at ti:/window.js:173: Uncaught TypeError: Cannot read property 'closed' of undefined
</pre></code>

It could be that this goes beyond windows methods... It's just that we know of this particular example.

<h4>Original Description</h4>
Running standard code causes internal runtime error. Log Attached.

There is a similar crash in Rhino.

Code works fine in iOS.

Steps to Reproduce:

1. Run Code:

<code><pre>
function Window1(){
	var self = {};
	
	var win =  Ti.UI.createWindow();
	var btn =  Ti.UI.createButton({
		title:'open',
		left:20,
		right:20,
		height:44
	});

	btn.addEventListener('click', function(){
		Window2().open();
	});

	win.add(btn);
	self.open = win.open;
	self.close = win.close;
	return self;
}

function Window2(){
	var self = {};
	
	var win = Ti.UI.createWindow({
		backgroundColor:'green'
	});
	win.addEventListener('open', function(){
		win.animate({
			left:10,
			duration:300
		}, function(){
			Ti.API.info('complete');
		});
	});
	var btn =  Ti.UI.createButton({title:'close', left:20,right:20,height:44});
	btn.addEventListener('click', function(){
		win.close();
	});
	win.add(btn);
	
	self.open = win.open;
	self.close = win.close;
	return self;
}

Window1().open();
</pre></code>

Expected Result:

App should run.

Actual Result:

Runtime error.

Note: This test code exists in <GitHub>/titanium_mobile_tests_internal/FeatureTest/Window/Window_timob7246
Note: Will investigate behavior on other devices in future.


<h3>Attachments</h3>

<table>
<thead>
<tr><th>File</th><th>Date</th><th>Size</th></tr><thead>
<tbody>
<tr><td><a href="https://jira-attachments.titaniumsdk.com/TIMOB/TIMOB-7413_25338/android v8 runtime error.txt">android v8 runtime error.txt</td></td><td>2012-01-25T17:23:25.000+0000</td><td>6992</td></tr>
</tbody>
<table>

<h3>Comments</h3>

<ol>
<li>Dustin Hyde 2012-01-30

   Same test code as TIMOB-7246.</li>
<li>Bill Dawson 2012-02-08

   Changed the title and description to reflect underlying problem.</li>
<li>Bill Dawson 2012-02-08

   <code>self.open = win.open</code> (and then calling <code>self.open();</code> via <code>Window1().open();</code>) is not really valid Javascript.  (I mean, it's syntactically okay, but the hoped-for behavior shouldn't occur.)  If it's working in iOS, then it's really kinda just luck, i.e., setting a window's <code>open</code> method to a variable and having it work successfully must mean that the method itself somehow has a pre-bound context to it due to some kind of plumbing in our iOS implementation.
   
   This similar plain-old Javascript code makes the point:
   
   <code><pre>
   var o = {
   	x: 5,
   	f: function() {
   		console.log("this.x == " + this.x);
   	}
   };
   var f = o.f;
   f();
   </pre></code>
   
   When you take <code>f</code> away from <code>o</code> it becomes "this-less", so to speak. :)  So the result is:
   
   <code><pre>
   this.x == undefined
   </pre></code>
   
   The same with <code>window.open</code>... When <code>open</code> is taken by itself, any code within it (when it is invoked) that tries  to manipulate "its" window ... its <code>this</code> ... is going to fail.
   
   You can get the test to work by changing those lines that set <code>self.open</code> and <code>self.close</code> so they do something like:
   
   <code><pre>
   self.open = function(){win.open();};
   </pre></code></li>
<li>Dustin Hyde 2013-05-01

   Closing.</li>
</ol>


<p><a href="/TIMOB/TIMOB-7413.json">JSON Source</a></p>