---
title: "[TIMOB-8381] iOS: ENSURE_ARG_OR_NIL_AT_INDEX macro does not handle NSNull instance"
---
<table>
<tr><th>Type</th><td>New Feature</td></tr>
<tr><th>Priority</th><td>Low</td></tr>
<tr><th>Status</th><td>Open</td></tr>
<tr><th>Resolution</th><td>Unresolved</td></tr>

<tr><th>Affected Version/s</th><td>Release 1.8.2</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>iOS</td></tr>
<tr><th>Labels</th><td>n/a</td></tr>
<tr><th>Reporter</th><td>Paul Mietz Egli</td></tr>
<tr><th>Assignee</th><td>Unknown</td></tr>
<tr><th>Created</th><td>2012-03-13T10:54:34.000+0000</td></tr>
<tr><th>Updated</th><td>2018-03-06T18:57:50.000+0000</td></tr>
</table>

<h3>Description</h3>

In my native module, I check for optional arguments to a method using the ENSURE_ARG_OR_NIL_AT_INDEX macro as follows:

<code><pre>
- (id)myMethod:(id)args {
    NSString * requiredArg;
    NSString * optionalArg1;
    NSNumber * optionalArg2;
    
    ENSURE_ARG_AT_INDEX(requiredArg, args, 0, NSString);
    ENSURE_ARG_OR_NIL_AT_INDEX(optionalArg1, args, 1, NSString);
    ENSURE_ARG_OR_NIL_AT_INDEX(optionalArg2, args, 2, NSNumber);
    
    /* remainder of method */
}
</pre></code>

This code is throwing an error when optionalArg1 is null:

<code><pre>
[ERROR] Invalid type passed to function. expected: NSString, was: NSNull  in -[TDDatabaseProxy(Insertion) putRevision:] (TDDatabaseProxy+TDDatabaseProxy_Insertion.m:43)
</pre></code>

Fix is to add a check for NSNull in the macro as shown on line 13 below:

<code><pre>
#define ENSURE_ARG_OR_NIL_AT_INDEX(out,args,index,type) \
if (args==nil || args==[NSNull null]) \
{ \
out = nil; \
} \
else if ([args isKindOfClass:[NSArray class]]) { \
if ([args count]>index) {\
out = [args objectAtIndex:index]; \
}\
else { \
out = nil; \
} \
if (out && ![out isKindOfClass:[NSNull class]] && ![out isKindOfClass:[type class]]) { \
[self throwException:TiExceptionInvalidType subreason:[NSString stringWithFormat:@"expected: %@, was: %@",[type class],[out class]] location:CODELOCATION]; \
} \
} \
</pre></code>

<h3>Comments</h3>

<ol>
<li>Paul Mietz Egli 2012-04-16

   Here's a version of the macro that converts NSNull to nil instead, which more closely matches the intent of passing a JavaScript null to a module function.  This is what I'm currently using for my projects.
   
   <code><pre>
   #define ENSURE_ARG_OR_NIL_AT_INDEX(out,args,index,type) \
   if (args==nil || args==[NSNull null]) \
   { \
   out = nil; \
   } \
   else if ([args isKindOfClass:[NSArray class]]) { \
   if ([args count]>index) {\
   out = [args objectAtIndex:index]; \
   }\
   else { \
   out = nil; \
   } \
   if ([out isKindOfClass:[NSNull class]]) { \
   out = nil;\
   }\
   if (out && ![out isKindOfClass:[type class]]) { \
   [self throwException:TiExceptionInvalidType subreason:[NSString stringWithFormat:@"expected: %@, was: %@",[type class],[out class]] location:CODELOCATION]; \
   } \
   } \
   </pre></code>
   </li>
</ol>


<p><a href="/TIMOB/TIMOB-8381.json">JSON Source</a></p>