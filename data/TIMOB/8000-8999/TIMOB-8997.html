---
title: "[TIMOB-8997] Android: Add the ability to distribute CommonJS modules along with a native module"
---
<table>
<tr><th>GitHub Issue</th><td>n/a</td></tr>
<tr><th>Type</th><td>New Feature</td></tr>
<tr><th>Priority</th><td>Critical</td></tr>
<tr><th>Status</th><td>Closed</td></tr>
<tr><th>Resolution</th><td>Duplicate</td></tr>
<tr><th>Resolution Date</th><td>2012-06-14T17:19:14.000+0000</td></tr>
<tr><th>Affected Version/s</th><td>n/a</td></tr>
<tr><th>Fix Version/s</th><td>n/a</td></tr>
<tr><th>Components</th><td>Android</td></tr>
<tr><th>Labels</th><td>n/a</td></tr>
<tr><th>Reporter</th><td>Marshall Culpepper</td></tr>
<tr><th>Assignee</th><td>Bill Dawson</td></tr>
<tr><th>Created</th><td>2012-05-04T12:31:01.000+0000</td></tr>
<tr><th>Updated</th><td>2017-03-21T22:40:59.000+0000</td></tr>
</table>

<h3>Description</h3>

Titanium needs a way to expose a JavaScript wrapper around a native module by providing a way to distribute CommonJS / JavaScript modules along side their native counter parts.

In theory, this might work something like:
<code><pre>
@Kroll.module
public class MyModule extends KrollModule
{
    @Kroll.method
    public void nativeMethod() {}
}
</pre></code>

<code><pre>
// in assets/myModule.js

var nativeModule = require("my.native.module.id");
exports.wrappedMethod = function() {
   return nativeModule.nativeMethod();
}
</pre></code>

<code><pre>
// now in the app.js

var myModule = require("myModule");
myModule.wrappedMethod();
</pre></code>

<h3>Comments</h3>

<ol>
<li>Bill Dawson 2012-05-10

   Dependency on TIMOB-4521 because a) it's in the same sprint; b) it will determine how we handle commonjs, period, in android module projects.</li>
<li>Bill Dawson 2012-05-30

   Please follow the linked items (dependencies) as well for status.
   
   This is a complex issue because:
   
   a) We need to maintain parity, and _none_ of the platforms (Android, iOS, MobileWeb) support this.  Therefore parity discussions and test cases will need to occur/be developed.
   
   b) This would require that both Javascript-based and native-based module code be executed at runtime, and the way modules are currently architected this won't work.
   
   Therefore we need to book substantially more time for this, and I've broken it down to the linked tasks.</li>
<li>Bill Dawson 2012-06-14

   At this point, this item basically duplicates TIMOB-9315, so I'm going to close it.  Follow the progress of TIMOB-9315, which is already at the pull request stage and therefore should be merged into our master branch in time for 2.1.0.
   
   TIMOB-9315 implements the ability to run both javascript (CommonJS) and native code in the same module.  The CommonJS file should be assets/[moduleid].js (substituting the actual module id of course.)  If we find such a file, we merge its exported members with the native module at runtime.
   
   So there's just a few alterations to marshall's suggested code above.  It would now look like this:
   
   <code><pre>
   @Kroll.module
   public class MyModule extends KrollModule
   {
       @Kroll.method
       public void nativeMethod() {}
   }
   </pre></code>
   
   <code><pre>
   // in assets/my.native.module.id.js
   
   exports.wrappedMethod = function() {
      return this.nativeMethod();
   }
   </pre></code>
   
   <code><pre>
   // now in the app.js
   
   var myModule = require("my.native.module.id");
   myModule.wrappedMethod();
   </pre></code>
   
   Note the use of "this" in the my.native.module.id.js file. It provides access to the native methods.</li>
<li>Lee Morris 2017-03-21

   Closing ticket as duplicate.</li>
</ol>


<p><a href="/TIMOB/TIMOB-8997.json">JSON Source</a></p>